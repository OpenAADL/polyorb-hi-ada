\input texinfo @c -*-texinfo-*-

@c %**start of header

@c oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
@c
@c                                Style Guide
@c
@c  1. Always put a @noindent on the line before the first paragraph
@c     after any of these commands:
@c
@c          @chapter
@c          @section
@c          @subsection
@c          @subsubsection
@c          @subsubsubsection
@c
@c          @end smallexample
@c          @end itemize
@c          @end enumerate
@c
@c  2. DO NOT use @example. Use @smallexample instead.
@c     a) DO NOT use highlighting commands (@b{}, @i{}) inside an @smallexample
@c        context.  These can interfere with the readability of the texi
@c        source file.  Instead, use one of the following annotated
@c        @smallexample commands, and preprocess the texi file with the
@c        gentexifile tool (which generates appropriate highlighting):
@c        @smallexample @c ada
@c        @smallexample @c adanocomment
@c        @smallexample @c projectfile
@c     b) The "@c ada" markup will result in boldface for reserved words
@c        and italics for comments
@c     c) The "@c adanocomment" markup will result only in boldface for
@c        reserved words (comments are left alone)
@c     d) The "@c projectfile" markup is like "@c ada" except that the set
@c        of reserved words include the new reserved words for project files
@c
@c  3. Each @chapter, @section, @subsection, @subsubsection, etc.
@c     command must be preceded by two empty lines
@c
@c  4. The @item command should be on a line of its own if it is in an
@c     @itemize or @enumerate command.
@c
@c  5. DO NOT put trailing spaces at the end of a line.  Such spaces will
@c     cause the document build to fail.
@c
@c  6. DO NOT use @cartouche for examples that are longer than around 10 lines.
@c     This command inhibits page breaks, so long examples in a @cartouche can
@c     lead to large, ugly patches of empty space on a page.
@c
@c  7. To add an entry to the bibliography, you must:
@c     * add it to polyorb-hi_ug.bib
@c     This will generate the correct polyorb-hi_ug_ref.texi file
@c     You may then cite the correct reference.
@c
@c oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

@c $Id: polyorb-hi-ada_ug.texi 7043 2009-10-08 14:20:49Z hugues $

@include version.texi

@setfilename polyorb-hi-ada_ug.info
@settitle PolyORB-HI User's Guide

@setchapternewpage odd
@syncodeindex fn cp

@c %**end of header

@c description and copyright

@copying
Copyright @copyright{} 2006-2009 @'{E}cole nationale sup@'{e}rieure
des t@'{e}l@'{e}communications

@noindent
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU Free Documentation License'', with the
Front-Cover Texts being ``PolyORB High Integrity User's Guide'', and
with no Back-Cover Texts.  A copy of the license is included in the
section entitled ``GNU Free Documentation License''.
@end copying

@titlepage

@title PolyORB High Integrity User's Guide
@subtitle Ada 2005 Edition
@subtitle Version @value{EDITION}
@subtitle Date: @value{UPDATED}
@author J@'er@^ome Hugues, Bechir Zalila
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@iftex
@contents
@end iftex

@c top node

@ifnottex
@node Top, About This Guide, (dir), (dir)
@top PolyORB High Integrity User's Guide
@insertcopying
@end ifnottex

@menu
* About This Guide::
* Introduction to PolyORB-HI-Ada::
* Installation::
* Building a system::
* Adding new transport mechanism::
* Supported features::
* AADL to Ada transformations::
* PolyORB-HI-Ada API::
* FAQ::
* References::
* GNU Free Documentation License::
* The Index::

@detailmenu
 --- The Detailed Node Listing ---

About This Guide

* What This Guide Contains::
* Conventions::

Installation

* Supported Platforms::
* Tree structure::
* Build requirements::
* Installation instructions::
* Build instructions::

Building a system

* Building examples::
* Building a new system::

Supported features

* Ada constructs::
* AADL features::

AADL to Ada transformations

* Whole distributed application::
* Distributed application nodes::
* Nodes::
* Threads::
* Connections::

@end detailmenu
@end menu

@ifhtml
@center @code{$LastChangedDate: 2009-10-08 16:20:49 +0200 (Thu, 08 Oct 2009) $}
@end ifhtml

@c -------------------------------------------------------------------

@c -------------------------------------------------------------------
@node About This Guide
@unnumbered About This Guide
@c -------------------------------------------------------------------

@noindent
This document describes PolyORB High-Integrity Ada (PolyORB-HI-Ada), a
reduced version of the PolyORB schizophrenic middleware
(@url{http://libre.adacore/com/polyorb}) for High-Integrity systems.

There are two versions of PolyORB High Integrity. The first, written
in Ada is called PolyORB-HI-Ada, and the other, written in C, is
called PolyORB-HI-C.  The following manual focuses on
PolyORB-HI-Ada.

@menu
* What This Guide Contains::
* Conventions::
@end menu

@c -------------------------------------------------------------------
@node What This Guide Contains
@unnumberedsec What This Guide Contains
@c -------------------------------------------------------------------

@noindent
This guide contains the following chapters:
@itemize @bullet

@item @ref{Introduction to PolyORB-HI-Ada} provides a brief description of
middleware and PolyORB-HI-Ada's architecture.

@item @ref{Installation} details how to configure and install PolyORB-HI-Ada
on your system.

@item @ref{Building a system} details how to build a distributed
system from its AADL description.

@item @ref{Adding new transport mechanism} details how to add
new transport mechanisms seamlessly to PolyORB-HI-Ada using AADLv2
features.

@item @ref{Supported features} details the features that are available
in PolyORB-HI-Ada,as well as the Ada restrictions for HI systems it
follows.

@item @ref{AADL to Ada transformations} details the mapping rules to
map an AADL model onto a High-Integrity Distributed System.

@item @ref{PolyORB-HI-Ada API} provides an overview of PolyORB-HI-Ada API.

@item @ref{FAQ} provides answers to Frequently Asked Questions.

@item @ref{References} provides a list of useful references to
complete this documentation.

@item
@ref{GNU Free Documentation License} contains the text of the license
under which this document is being distributed.
@end itemize

@c -------------------------------------------------------------------
@c generic typographical conventions
@include conventions.texi
@c -------------------------------------------------------------------

@c -------------------------------------------------------------------
@node Introduction to PolyORB-HI-Ada
@chapter Introduction to PolyORB-HI-Ada
@cindex PolyORB-HI-Ada
@c -------------------------------------------------------------------

@noindent
PolyORB-HI-Ada is a middleware for High-Integrity Systems, it inherits
most concepts of the schizophrenic middleware @i{PolyORB} while being
based on a complete new source code base, compatible with the
Ravenscar profile and the restrictions for High-Integrity systems.

In order to ease the construction of Distributed High-Integrity
Systems, PolyORB-HI-Ada relies on the AADL language and the Ocarina
toolsuite (@cite{[VZ06]}) to allocate statically all required
resources and generate stubs, skeletons, marshallers and concurrent
structures. Hence, PolyORB-HI-Ada acts as an AADL runtime.

Ocarina supports both AADLv1 @cite{[SAE04] }and AADLv2 @cite{[SAE09a]}
as input models, and the data modeling @cite{[SAE09b]} and programming
languages annexes @cite{[SA09c]}.

This manual describes the elements specific to PolyORB-HI-Ada.

@c -------------------------------------------------------------------
@node Installation
@chapter Installation
@c -------------------------------------------------------------------

@menu
* Supported Platforms::
* Tree structure::
* Build requirements::
* Installation instructions::
* Build instructions::
@end menu

@c -------------------------------------------------------------------
@node Supported Platforms
@section Supported Platforms
@c -------------------------------------------------------------------

@noindent
PolyORB-HI-Ada has been compiled and successfully tested on 

@itemize @bullet
@item native platforms:

@itemize @bullet
@item Linux
@item Mac OS X
@item Solaris
@item FreeBSD
@item Windows
@end itemize

@item Real-Time Operating Systems (RTOS) for Embedded systems

@itemize @bullet
@item MaRTE OS, by Universidad de Cantabria,
@item RTEMS, by OAR Corp.
@end itemize

@item bare-board platforms

@itemize @bullet
@item ERC32, using GNAT Pro for ERC32 
@item LEON, using GNAT Pro for LEON 6.2.1 or above,
or GNAT for LEON 2.1.0 by Universidad Politecnic de Madrid,
@end itemize
@end itemize

@noindent
@emph{Note: PolyORB-HI-Ada should compile and run on every target for
which GNAT is available}

@c -------------------------------------------------------------------
@node Tree structure
@section Tree structure
@c -------------------------------------------------------------------

@noindent
PolyORB-HI-Ada source distribution has the following tree structure:

@itemize @bullet
@item @file{doc/}: this documentation,
@item @file{examples/}: set of examples to test PolyORB-HI-Ada
@item @file{share/}: common files
@item @file{src/}: core of PolyORB-HI-Ada
@item @file{tools/}: helper executables to run multi-nodes applications
@item @file{ChangeLog}: release information,
@item @file{COPYING}: GPLv2 license document,
@item @file{README}: short description of the distribution.
@item @file{INSTALL}: quick installation instruction
@end itemize

When installed with Ocarina, in @file{$OCARINA_PATH} directory

@itemize @bullet
@item docutmentation is in @file{$OCARINA_PATH/share/doc/ocarina};
@item examples are in @file{$OCARINA_PATH/examples/ocarina/polyorb-hi-ada/}: 
set of examples to test PolyORB-HI-Ada
@item runtime files are in 
@file{$OCARINA_PATH/include/ocarina/runtime/polyorb-hi-ada/}.
@end itemize

@c -------------------------------------------------------------------
@node Build requirements
@section Build requirements
@c -------------------------------------------------------------------

@noindent
To be compiled, PolyORB-HI-Ada requires the following tools:

@itemize @bullet
@item For native platforms: a recent version of the GNAT compiler,
  e.g. GNAT Pro 6.2.1 or above, GNAT @{GAP, GPL@} 2008 or later or
  GNAT GCC 4.3.0 or later

@item For LEON targets: the GNAT for LEON 2.1 or above; or GNAT Pro 
  6.2.1 or above

@item For ECR32: the GNAT for ERC32 2006 or later.
@end itemize

PolyORB-HI-Ada also relies on AADL-to-Ada code generation features
provided by Ocarina. Therefore, it is important to select a version of
Ocarina that is compatible with this version of
PolyORB-HI-Ada. Whenever possible, pick a unified archive that
contains both tools.

@c -------------------------------------------------------------------
@node Installation instructions
@section Installation instructions
@c -------------------------------------------------------------------

@noindent
To install PolyORB-HI-Ada, please observe the following steps:

@itemize
@item 
Install GNAT and Ocarina as specified by their respective
documentations and make sure their 'bin/' installation directories are
located at the top of your PATH environment variable.

@item 
Issue @code{./configure}. The @code{configure} script can take several
options: issue @code{./configure --help} to have a quick overview of
them. For examples. @code{./configure --enable-debug} will configure
the middleware to be built with all debug options.

@item Issue @code{make && make install}
@end itemize

@c -------------------------------------------------------------------
@node Build instructions
@section Build instructions
@c -------------------------------------------------------------------

@noindent
PolyORB-HI-Ada must be installed correctly in order to be able to build
examples.

To compile all examples, simply issue @code{make examples} from the
main source directory. To clean the examples, issue @code{make
clean-examples} from the main source directory.

The examples may be built with the debug information and with the GNAT
compiler checks to make their debugging possible. In this case the
footprint of the generated binaries is about almost 1MB per
executable. This is the default behavior of the @code{make examples}
command. If the user wants to make the examples without any debug
information and any GNAT check, he should use the @code{make examples
'BUILD=Release'} command instead. The footprint of the generated
executable will be reduced considerably.

Each example uses the GNAT build infrastructure and a makefile.

For each example, a makefile is provided with the following rules:

@itemize @bullet
@item 
@code{build-all}: generate code from the example and compile it;

@item 
@code{clean}: clean all generated files;

@end itemize

@c -------------------------------------------------------------------
@node Building a system
@chapter Building a system
@c -------------------------------------------------------------------

@noindent
In this chapter, we discuss the construction of an application, using
PolyORB-HI-Ada and an AADL model of the application.

@menu
* Building examples::
* Building a new system::
@end menu

@c -------------------------------------------------------------------
@node Building examples
@section Building examples
@c -------------------------------------------------------------------

Each example provides a makefile that does the following steps:

@enumerate
@item parse the AADL model;
@item generate Ada code from the AADL model;
@item compile each node, enforcing coding restrictions detailed
in the several @code{.adc} files.
@end enumerate

PolyORB-HI-Ada comes with different examples and configurations, please
refer to @file{examples/README} and subsequent documentation files for
more details.

@c -------------------------------------------------------------------
@node Building a new system
@section Building a new system
@c -------------------------------------------------------------------

To build your own system, you have two choices: using a scenario file
or the command line.

@itemize @bullet
@item To use a scenario file, please follow these instructions

@enumerate
@item build a scenario file, a scenario file is an AADL file containing a
system describing your applications (AADL files, code generator,
needed Ocarina non-standard property sets, ...). Here is an example
from the @i{Ping} example:

@include scenario_local_gnat.texi

@item issue the command @code{ocarina -b -x <scenario-file>}

@end enumerate

@item To use command line, please follow these instructions
@enumerate
@item issue the command @code{ocarina -g polyorb_hi_ada <list-of-aadl-files>}
@end enumerate

@end itemize

@noindent
For a list of supported flags, please refer to the @i{Ocarina User's
Guide}.

@c -------------------------------------------------------------------
@node Adding new transport mechanism
@chapter Adding new transport mechanism
@c -------------------------------------------------------------------

@noindent
In this section, we detail how to add new transport mechanisms
seamlessly to PolyORB-HI-Ada using AADLv2 features.

We base the following on the example found in the examples directory,
named @file{aadlv2/device_drivers}.

We use AADLv2 features to add integrate device drivers to
PolyORB-HI/Ada. To do so, you need to perform the following steps

@enumerate

@item 
First, you need to define a device and point to an abstract AADLv2
component that supports its full implementation using the
@code{Implemented_As} property. This abstract component will define
all internals of the device driver.

@include device_drivers.texi

@item 
The abstract implementation shall define or reference required thread,
subprograms. 

@enumerate
@item 
AADL entities shall define threads and subprograms to handle incoming
requests, unmarshall them, and do the upcall to PolyORB-HI-Ada
internals. See code provided for the AADL subprogram
@code{TCP_IP.Send}.

@item 
User provided code shall define a subprogram to marshall and send
data.  This subprogram shall be exported using Ada @code{pragma
Export}. The name of the corresponding symbol shall be made as follows
@i{<name_of_device>_send}. 

In the @code{device_drivers} example, this name is
@code{tcp_ip_device.impl_send}.


@b{Note:} it is the user responsibility to ensure that
marshalling/unmarshalling is performed correctly.

@item 
In addition, you may add an initialisation procedure for this driver
using the @code{Initialize_Entrypoint}.

This function takes as input parameter one naming table as defined in
the deployment table. This naming table shall be used to
@itemize
@item Open incoming communication channels
@item Open channels to remote nodes
@end itemize

@xref{Distributed application nodes}.

@end enumerate

@end enumerate

@c -------------------------------------------------------------------
@node Supported features
@appendix Supported features
@c -------------------------------------------------------------------

@noindent
PolyORB-HI-Ada is a middleware dedicated to High-Integrity
systems. Therefore, it relies on a limited subset of AADL and Ada
features, and allow the user to enforce a large set of restrictions.

Here is the list of restrictions allowed, and enforced by Ocarina and
the Ada compiler.

@menu
* Ada constructs::
* AADL features::
@end menu

@c -------------------------------------------------------------------
@node Ada constructs
@section Ada constructs
@c -------------------------------------------------------------------

@noindent
PolyORB-HI-Ada strictly follows Ada restrictions for High-Integrity
systems. They are enforced through different compilation files:

@itemize @bullet
@item The files @file{gnat.adc} lists common restrictions applied to
all compiled files

@include gnat.texi

@item @file{native.adc}  lists restrictions applied to compiled files
for native targets

@include native.texi

@item @file{hi-e.adc}  lists restrictions applied to compiled files
for High-Integrity targets such as bare board LEON and ERC32
compilers.

@include hi-e.texi

@item The file @file{polyorb-hi.gpr} lists the compilation options
applied to all units, the different supported targets
(@code{``native''}, @code{``leon''} and @code{``erc 32''}).
@end itemize

The @code{check} rule of the makefile allows one to check for the
remaining restrictions, using the @file{gnatcheck} tool.

@c -------------------------------------------------------------------
@node AADL features
@section AADL features
@c -------------------------------------------------------------------

@noindent
PolyORB-HI-Ada acts as an AADLv1 or AADLv2 runtime. AADL is a complete
description language. Some features cannot be implemented or supported
by restricted HI runtimes.

This section lists AADL features supported by PolyORB-HI-Ada:

@itemize @bullet
@item asynchronous, oneway calls;
@item data component types of statically bounded size;
@item all compile-time and run-time restrictions enforced as part of
  the compilation process;

@item User code must conform with the data modeling annex 
(@cite{[SAE09b]}), and the programing language annex
(@cite{[SA09c]}).

Please refer to these documents for more details.

@item PolyORB-HI-Ada can use different transport infrastructures:

@itemize @bullet
@item on native platform, distribution can be tested using the native
socket library provided by @code{GNAT.Sockets}.

@item user-provided transport layer can be used, provided they follow 
guidelines discussed in section @xref{Adding new transport mechanism}.
@end itemize
@end itemize

@c -------------------------------------------------------------------
@node AADL to Ada transformations
@appendix AADL to Ada transformations
@c -------------------------------------------------------------------

@menu
* Whole distributed application:: 
* Distributed application nodes:: 
* Nodes:: 
* Threads:: 
* Connections:: 
@end menu

In this chapter, we introduce some of the code patterns that are
generated for each AADL entity.  These mapping rules will be
illustrated using the following example of a distributed application:

@image{fig/ping, 12cm}

The figure above shows the architecture of the @emph{Ping} example: a
client, which is a process containing one single @i{periodic} thread,
sends a message to the server which is a process containing one
@i{aperiodic cyclic} thread that handles incoming ping messages from
the client. Each node of the @emph{Ping} application runs on a
different machine.

This graphical example has been adapted as textual AADLv1 and AADLv2
models, and is available in the @file{examples/aadlv1/ping} or
@file{examples/aadlv2/ping}.

@c -------------------------------------------------------------------
@node Whole distributed application
@section Whole distributed application
@c -------------------------------------------------------------------

A distributed application is an application which is composed by
interacting nodes. In this section, we give the AADL entities used to
model a distributed application. Then, we give the rules applied to
map these AADL entities onto instances of PolyORB-HI-Ada components,
expressed as Ada code.

In the following, we detail only the rules that are directly related
to the distributed application as a whole system. The rules that are
specific to the components of the distributed application are
explained later.

@subsection AADL entities

To model a distributed application in AADL we use the @code{system}
component. The system implementation shown on the following example
models such system.

@include ping_native.texi

For each node (process) of the distributed application, we
instantiate a subcomponent in the system implementation.

We use the @code{properties} section of the AADL @code{system} (see
@ref{Nodes} for more details) to map the logical nodes (processes)
onto the physical nodes (processors). The @code{connections} section of
the system implementation models the connections between the different
nodes of the application.

@subsection Ada mapping rules

A distributed application is mapped into a hierarchy of directories:

@itemize @bullet
@item 
the root directory of the distributed application has the same
name as the system implementation that models the application, in
lower case, all dots being converted into underscores. This directory
is the root of the directory hierarchy of the generated Ada
distributed application.

@item 
for each node of the distributed application, a child directory having
the same name as the corresponding process subcomponent (in lower
case) is created inside the root directory. This child directory will
contain all the code generated for the particular node it was created
for (see @ref{Distributed application nodes} for more details).
@end itemize

@c -------------------------------------------------------------------
@node Distributed application nodes
@section Distributed application nodes (processes)
@c -------------------------------------------------------------------

In this section, we give the AADL entities used to model a node of
distributed application. Then, we give the rules applied to map Ada
code from these AADL entities. Only rules that are related directly to
a node as a whole subsystem are listed here. The rules that are
specific to the sub-components of a node are explained in the sections
that deal with these respective sub-components.

@subsection AADL entities

To model a distributed application node in AADL we use the
@code{process} component. The process implementation shown in the
listing below shows such system. For each node of the
distributed application, we add a process instantiation as
subcomponent in the system implementation that models the distributed
application.

@include node_a_model.texi

For each thread that belongs to a node of the distributed application,
we instantiate a subcomponent in the process implementation. For each
connection between a node and another, a @code{port} feature has to be
added to both nodes with the direction @code{out} for the source and
@code{in} for the destination (see @ref{Connections} for more details
on connections mapping).

@subsection Ada mapping rules

All the Ada entities mapped from a distributed application node, are
created in a child directory of the directory mapped from the
distributed application. This directory has the same name as the
process @emph{subcomponent} instance relative to the handled node in
the system implementation that model the distributed application, in
lower case.

For example, all the entities relative to @code{Node_A}, an instance
of the process @code{A} of the @code{Ping} example are generated in
the directory @code{ping_impl/node_a}.

The following paragraphs list the Ada compilation units that are
created for each node of the distributed application.

@subsubsection Data marshallers

The data marshallers are generated in a package called
@code{PolyORB_HI_Generated.Marshallers}. This package provides
routines to convert the data types used in the node and other useful
generated type to a representation suitable for transmission over
network.

@include node_a_marshallers.texi

The body of @code{PolyORB_HI_Generated.Marshallers} instantiates of
the generic package @code{PolyORB_HI.Marshallers_G} for the
corresponding types. The generic package
@code{PolyORB_HI.Marshallers_G} is part of PolyORB-HI-Ada
components. The example above shows the specification of the generated
@code{PolyORB_HI_Generated.Marshallers} mapped from the @code{Node_A}
node of the @code{Ping}.

@subsubsection Node activity

We denote ``activity'' the set of the actions performed by one
particular node. This denotes particularly the periodic, sporadic and
hybrid threads that belongs to this node.

The code related to the node activity is generated in an Ada package
called @code{PolyORB_HI_Generated.Activity} as shown in the following
example:

@include node_a_activity.texi

All the naming rules explained in @ref{Whole distributed application}
are also applied to map the package name. The
@code{PolyORB_HI_Generated.Activity} package contains all the routines
mapped from the threads that belong to the handled node. This package
contains also the instances of shared objects used in this node.
@xref{Threads}.

@subsubsection Data types

All the data types mapped from AADL data components and used by a
particular node of a distributed application are gathered in a
separate Ada package called @code{PolyORB_HI_Generated.Types}. The
name of this package is fixed for the sake of simplicity because it
may be used by the user implementation code. The user does not have to
change his implementation code if he renamed its distributed
application.

@include node_a_types.texi

@subsubsection Subprograms

The mapping of all AADL subprogram components used by a particular
node is generated in a separate Ada package. The name of this package
is @code{PolyORB_HI_Generated.Subprograms} as shown in the following
example:

@include node_a_subprograms.texi

@subsubsection Deployment information

The deployment information is the information each node has on the
other nodes of the distributed applications. This information is used,
in conjunction with the naming table (see the next paragraph) to allow
a node to send a request to another node or to receive a request from
another node. The deployment information is generated for each node in
the package @code{PolyORB_HI_Generated.Deployment}.

The @code{PolyORB_HI_Generated.Deployment} package contains several
Ada enumeration types:

@itemize @bullet
@item 
@code{Node_Type}. For each node in the application accessible from the
current node, we create an enumeration literal whose name is mapped
from the node ``instance'' declared in the system implementation to
which we concatenate the string ``_K''. All the naming rules listed in
@ref{Whole distributed application} have to be respected.

In addition, the constant @code{My_Node} of type @code{Node_Type} is
defined and store the value of the current node.

@item 
@code{Entity_Type}. For each thread in the application that belongs to
the current node or that is connected (via its owner process) to one
of the threads of the current node, we declare an enumeration
literal. The defining identifier of the enumerator is mapped from the
process subcomponent name and the thread subcomponent name as follows:
@code{<Node_Name>_<Thread_Name>_K}. All the naming rules listed in
@ref{Whole distributed application} must be respected.

@item
@code{Port_Type}. For each thread port in the distributed applications
accessible from the current node, we declare an enumeration
literal. Only threads that belongs to the @code{Entity_Type}
enumeration are mapped.
@end itemize

For each table, Ada enumeration clauses are generated to guarantee
that each enumeration literal has a unique value across partitions.

The table called @code{Entity_Table} is generated to map threads to nodes,
and @code{Port_Table} to maps port to threads.

Finally, we generate a constant (@code{Max_Payload_Size}) that
indicates the maximal size (in bits) of a message handled in the
current node. This size is computed automatically from the set of data
types handled (sent or received) in the node. It will be used to
configure the @code{PolyORB_HI.Messages} package.

The following example shows the @code{PolyORB_HI_Generated.Deployment}
package relative to the node @code{Node_A} of the @code{Ping} example:

@include node_a_deployment.texi

@subsubsection Naming information

The naming information for a particular node allows this node to send
requests to another node in the distributed application and to receive
a request from another node. It contains for each node, the
information necessary to establish a connection with a remote
node. These information are deduced statically from the AADL model.

The naming information is generated in a package called
@code{PolyORB_HI_Generated.Naming}.

@include node_a_naming.texi

As shown in the example above, for the node @code{Node_A} of the
@code{Ping} example, the @code{PolyORB_HI_Generated.Naming} package
contains:
@itemize @bullet
  @item A static table called @code{Naming_Table} indexed by means of
  the @code{Node_Type} declared in the
  @code{PolyORB_HI_Generated.Deployment} package. This table contains,
  for each node of the distributed application, all the information
  necessary to establish a connection with this node.
@end itemize

@subsubsection Transport Layer

The transport high-level layer is generated automatically for each
node of the application in a package called
@code{PolyORB_HI_Generated.Transport}. This package contains the
routines to send and receive messages between the threads of the
application, either locally or remotely, depending on the source and
the destination of the message. In case of remote communication, the
transport high-level layer will invoke the routines of the transport
low level layer depending on the kind of the connection between the
source and the destination.

The example below shows the @code{PolyORB_HI_Generated.Transport}
generated for the node @code{Node_A} of the @code{Ping} example.

@include node_a_transport.texi

@subsubsection Main subprogram

The main subprogram is an Ada subprogram that does all the necessary
initialization before the effective run of the node. The defining
identifier of the main subprogram is mapped from the process
subcomponent ``instance'' declared in the system implementation. All
the naming rules listed in @ref{Whole distributed application} have to
be respected.

The body of the main subprogram contains the initialization of the
communication transport layer, then we no longer need the main task,
so we suspend it for ever. The following example shows the main
subprogram generated for the node @code{Node_A} of the @code{Ping}
example.

@include node_a_code-body.texi

In order to elaborate correctly the tasks, a special elaboration
clause has to be added for the @code{PolyORB_HI_Generated.Activity}
package in the main subprogram when the node contains periodic threads
(see the example above).

@c -------------------------------------------------------------------
@node Nodes
@section Nodes
@c -------------------------------------------------------------------

A node is the set formed by a processor and an operating system (or
real-time kernel).

In this section we present the AADL entities used to model a node.
Then, we give the mapping rules used to generate Ada code expressing
that a node runs on a particular node.

@subsection AADL entities

To model both the processor and the OS, we use the @code{processor}
AADL component. The characteristics of the processor are defined using
the AADL properties. For example, if our distributed application uses
an IP based network to make its node communicate, then each node must
have an IP address. Each node must also precise its platform (native,
LEON...). The listing following example shows how to express this
using a custom property set.

@include hardware.texi

To map an application node (processor) to a particular node, we use
the @code{Actual_Processor_Binding} property. The following example
shows how the node @code{Node_A} is mapped to the processor
@code{Proc_A} in the @code{Ping} example.

@include processor_binding.texi

@subsection Ada mapping rules

The Ada generated code concerning the code generation to model node
mapping is located in the @code{PolyORB_HI_Generated.Naming}
package. More precisely, the @code{Naming_Table} contains, for each
node, the information related to its node. These information are
dependant on the transport mechanism used in the distributed
application.

@c -------------------------------------------------------------------
@node Threads
@section Threads
@c -------------------------------------------------------------------

The threads are the active part of the distributed application. A node
must contain at least one thread and may contain more than one
thread. In this section, we give the AADL entities used to model
threads. Then, we give the mapping rule to generate Ada code
corresponding to the periodic and aperiodic threads.

The rules are listed relatively to the packages generated for the
nodes and for the distributed application (see @ref{Distributed
application nodes} and @ref{Whole distributed application}). Only
rules that are related directly to a thread as a whole subsystem are
listed here.

@subsection AADL entities

The @code{thread} AADL components are used to model threads in the
distributed application. The @code{features} section of the thread
component declaration describes the thread's interface (the ports that
may be connected to the ports of other threads). The @code{properties}
section of the thread implementation lists the properties of the
thread such as its priority, its nature (periodic, sporadic or hybrid)
and many other properties are expressed using AADL properties. The
@code{calls} section of the thread implementation contains the
sequences of subprograms the thread may call during its job. If the
thread job consist of calling more than one subprogram, it is
@b{mandatory} to encapsulate these calls inside a single subprogram
which will consist the thread job. The thread job may also be
specified by means of the standard AADL property
@code{Compute_Entrypoint} applied to the thread or else to all its
``IN EVENT [DATA] ports''.The @code{connections} section of a thread
implementation connects the parameters of the subprograms called by
the thread to the ports of the thread or to the parameters of other
called subprograms in the same thread.

@include thread_a.texi

The listing above shows the thread @code{P} which belongs to the
process @code{A} in the @code{Ping} example. We can see that @code{P}
is a periodic thread with a period of 1000ms, that this thread has a
unique @code{out event data port} and that at each period, the thread
performs a call to the @code{Do_Ping_Spg} subprogram whose @code{out
parameter} is connected to the thread port.

@subsection Ada mapping rules for AADL threads

Periodic threads are @emph{cyclic} threads that are triggered by and
only by a periodic time event. between two time events the periodic
threads do a non blocking job and then they sleep waiting for the next
time event.

Sporadic threads are @emph{cyclic} threads that are triggered by a
sporadic event. The minimum inter-arrival time between two sporadic
event is called the period of the sporadic thread.

Hybrid threads are @emph{cyclic} threads that have a periodic behavior
triggered by a periodic time event. They have also a sporadic behavior
that is triggered by the reception of an external event between two
occurrences of their period.

In the following, ``threads'' will denote periodic, sporadic and hybrid
threads unless the contrary is explicitly precised.

@subsubsection Node activity

The majority of the code generated for threads is put in the
@code{PolyORB_HI_Generated.Activity} package generated for the
application node containing the handled thread. The generated entities
are:

@itemize @bullet
@item
An enumeration type listing all the ports of the thread. The name of
the type is mapped from the thread instance name suffixed with
``@code{_Port_Type}''. The name of each enumerator is mapped form the
corresponding port name. All the naming rules listed in @ref{Whole
distributed application} hold.

For ``hybrid'' AADL threads, an extra in event port is added to the
enumeration. This port is called @code{"Period_Event_Ü"}. It will
receive the period occurrences from the hybrid tasks driver.

@item
A discriminated record type (with the port type as discriminant) to
describe the thread interface. the name of each field (in case of a
data port) is mapped from the port name to which we add
``@code{_DATA}'' and the type is the Ada type mapped from the data
component corresponding to the port. All the naming rules listed in
@ref{Whole distributed application} hold.

@item
a set of subprograms allowing the user code to manipulate the thread
interface (see the thread part of the AADL standard for more details).

@item 
a subprogram that represents the thread job. The defining identifier
of the subprogram is mapped from the thread instance name in the
process that models the node, to which we append the string
``@code{_Job}''. All the naming rules listed in @ref{Whole distributed
application} have to be respected. The body of this subprogram calls
the subprograms mapped from the subprogram calls the thread
performs. Then, it sends the request to the remote threads it may be
connected to. For periodic threads, the job subprogram is
parameter-less. For sporadic threads, the job subprogram takes one
parameter, the port the enumerator corresponding to the port that
triggered the thread. For hybrid threads, if the thread has only a
compute entrypoint then the job subprogram must have one parameter,
the port the enumerator corresponding to the port that triggered the
thread. If the hybrid thread has been assigned a compute entry point
for each one of its ports, the job subprogram must be parameter-less.

@item
an Ada task. To simplify code generation, we just instantiate a
generic package supplied with the PolyORB-HI-Ada runtime:
@code{PolyORB_HI.Cyclic_Task}, @code{PolyORB_HI.Sporadic_Task} or
@code{PolyORB_HI.Hybrid_Task}. This creates a task with the wanted
properties at the elaboration time of the node. The package
instantiation name is mapped from the thread instance name in the
process that model the node, to which we append the string
``@code{_Task}''. All the naming rules listed in @ref{Whole
distributed application} hold. The package instantiation takes the
following parameters:

@itemize @bullet 
@item
the enumerator corresponding to the thread

@item 
the task period or inter-arrival time,

@item 
the task priority. If the user did not specify a priority, then
@code{System.Default_Priority} is used,

@item 
the task stack size. If the user did not specify a stack size, then
the 64Kb default size is used, 

@item
for sporadic and hybrid threads only, the subprogram that is called to
wait for incoming events.

@item 
the task job which corresponds to the subprogram
@code{<Thread_Name>_Job}.

@item
an optional subprogram to initialize the thread (given by standard
property @code{"Initialize_Entrypoint"}.
@end itemize
@end itemize

@strong{IMPORTANT NOTE: } If a node contains at least one hybrid
thread, an extra ``driver'' task is added to this node to awaken hybrid
tasks at their period occurrences by sending an event to their extra
in event port. The priority of this task is equal to the maximal
system task priority.

@c -------------------------------------------------------------------
@node Connections
@section Connections
@c -------------------------------------------------------------------

The connections are entities that support communication between the
application nodes. In this section, we present the AADL entities used
to model connection between nodes. There is no implicit mapping rules
for AADL connections, they just help to know the data flow (in case of
data connections) and some aspects of the control flow (event
connections) in the distributed application.

@subsection AADL entities

As said in @ref{Distributed application nodes} and @ref{Whole
distributed application} a connection between two nodes of the
distributed application is modeled by:
@itemize @bullet
  @item The @code{ports} features that exist on each one of the
  nodes. Ports can be declared inside processes or threads. The
  direction of the port (@code{in}, @code{out} or @code{in
  out}) indicates the direction of the information flow.

  @item The @code{connections} section in the system implementation
  relative to the distributed application and in the process and
  thread implementations.
@end itemize

@include port_cnx.texi

The listing above shows the connection between the node @code{A} and
@code{B} in the system implementation.

The nature of the @code{port} (@i{event port}, @i{data
port} or @i{event data port}) depends on the nature of the
connection between the two nodes:
@itemize @bullet
 @item if the message sent from one node to another node is only a
 triggering event and contains no data, we create an @i{event}
 port.

 @item if the message sent from one node to another node is a data
 message but it does not trigger the receiver thread, we create a
 @i{data} port.

 @item if the message sent from one node to another node is a data
 message that triggers the receiver thread, we create an @i{event
 data} port.
@end itemize

@c -------------------------------------------------------------------
@node PolyORB-HI-Ada API
@appendix PolyORB-HI-Ada API
@c -------------------------------------------------------------------

This section lists the API of PolyORB-HI-Ada, used to support the basics
of distribution features and concurrent interactions.

@include polyorb-hi-ada_api.texi

@c -------------------------------------------------------------------
@node FAQ
@appendix Frequently Asked Questions
@c -------------------------------------------------------------------

In this section, we list frequent questions related to code generation
patterns.

@enumerate
@item @i{How are allocated buffers that store messages ?}

Ocarina has a complete view over the system models. In particular,
based on the knowledge of user types, Ocarina computes the maximum
size of the payload to be sent, and stores it in the
@code{PolyORB_HI_Generated.Deployment.Max_Payload_Size} constant.
@xref{Distributed application nodes}.

@item @i{How many Ada task are generated ?}

@itemize
@item For each process, Ocarina generates one task per AADL thread, plus one
additional task per process that holds an AADL @code{Hybrid}
thread. @xref{Threads}.

@item If this process relies on pre-defined transport protocol (using the
@code{Deployment_Transport_API} property with a value different from
@code{None} or @code{User}), then an additional task is added.
@end itemize

@item @i{How many Ada protected objects are generated ?}

@itemize
@item For each process, Ocarina instantiates one protected object per AADL
thread with ``in'' ports, as part of the instantiation building node
activity.  @xref{Distributed application nodes}.

@item In addition, for each AADL data component whose
@code{Concurrency_Protocol_Policy} is @code{Priority_Ceiling}, Ocarina
builds one protected object.
@end itemize

@item @i{How to enable debug information ?}

To enable debug, you must configure PolyORB-HI-Ada with the
@code{--enable-debug} flag.  @xref{Installation instructions}.

@item @i{How to display log information ?}

To display log information at runtime, you need to change the value of
@code{PolyORB_HI.Output.Current_Mode}.

@end enumerate

@c -------------------------------------------------------------------
@node References
@appendix References
@c -------------------------------------------------------------------

@enumerate

@include polyorb-hi_ug_ref.texi

@end enumerate

@c -------------------------------------------------------------------
@c GNU's FDL

@include gfdl.texi

@c -------------------------------------------------------------------
@node The Index
@unnumbered The Index
@c -------------------------------------------------------------------

@printindex cp

@bye

@c %%% Local Variables:
@c %%% mode: texinfo
@c %%% mode: flyspell
@c %%% ispell-dictionary: "en"
@c %%% End:
